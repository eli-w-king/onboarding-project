<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenRouter Chat</title>
    <style>
        @font-face {
            font-family: 'Supreme';
            src: url('Supreme-font-WEB/fonts/Supreme-Regular.woff2') format('woff2'),
                 url('Supreme-font-WEB/fonts/Supreme-Regular.woff') format('woff');
            font-weight: normal;
            font-style: normal;
        }
        
        @font-face {
            font-family: 'Supreme';
            src: url('Supreme-font-WEB/fonts/Supreme-Extralight.woff2') format('woff2'),
                 url('Supreme-font-WEB/fonts/Supreme-Extralight.woff') format('woff');
            font-weight: 200;
            font-style: normal;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Supreme', sans-serif;
        }

        body {
            background-color: #ffffff;
            display: flex;
            flex-direction: column;
            height: 100vh;
            position: relative;
            overflow: hidden;
        }

        /* Background animation removed */
        
        /* Soft glow animation kept for input elements */
        @keyframes softGlow {
            0% { box-shadow: 0 0 5px rgba(33, 150, 243, 0.1); }
            50% { box-shadow: 0 0 15px rgba(33, 150, 243, 0.2); }
            100% { box-shadow: 0 0 5px rgba(33, 150, 243, 0.1); }
        }

        .api-key-container {
            background-color: transparent;
            padding: 8px 15px;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: nowrap;
            width: 100%;
            min-height: 48px;
        }
        
        @media (max-width: 600px) {
            .api-key-container {
                padding: 8px 10px;
                gap: 6px;
            }
            .api-key-container input {
                min-width: 0;
                font-size: 13px;
                width: 100%;
                padding: 12px 18px;
                height: 44px;
            }
        }

        .api-key-container input {
            flex-grow: 1;
            width: 100%;
            min-width: 0;
            max-width: none;
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 15px;
            box-shadow: none;
            transition: border-color 0.3s ease;
            text-align: left;
            box-sizing: border-box;
            height: 36px;
        }
        
        .api-key-container input::placeholder {
            text-align: left;
            color: #999;
            font-family: 'Supreme', sans-serif;
            font-weight: 200;
        }
        
        .api-key-container input:focus {
            outline: none;
            border-color: #2196f3;
            box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.1);
        }
        
        .api-key-link {
            margin-left: 0;
            display: flex;
            align-items: center;
            height: 100%;
            padding-top: 0;
            padding-bottom: 0;
        }
        
        .help-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background-color: #2196f3;
            color: white;
            font-size: 12px;
            font-weight: bold;
            text-decoration: none;
            margin: 0;
        }
        
        .api-key-link:hover .help-icon {
            background-color: #0b7dda;
            transform: scale(1.1);
            transition: all 0.2s ease;
        }

        .model-selector {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            min-width: 200px;
        }

        .chat-container {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            overflow: hidden;
            max-width: 1000px;
            margin: 0 auto;
            width: 100%;
            padding: 20px;
            position: relative;
            overflow: hidden;
            background-color: transparent;
        }

        /* Chat border animation removed */

        .messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px 0;
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 0 5px;
        }

        .message {
            padding: 16px 32px;
            border-radius: 48px;
            max-width: 85%;
            word-break: break-word;
            line-height: 1.6;
            transition: all 0.5s cubic-bezier(0.25, 0.1, 0.25, 1);
            animation: messageFadeIn 0.5s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
            opacity: 0;
            will-change: opacity, transform;
            transform-style: preserve-3d;
            backface-visibility: hidden;
            /* Prevent layout shifts and improve rendering performance */
            contain: layout style;
            min-height: 56px;
            display: flex;
            align-items: center;
        }

        @keyframes messageFadeIn {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .user {
            align-self: flex-end;
            background-color: #f9f9f9;
            border-radius: 48px;
            border: 1px solid #f0f0f0;
            animation-delay: 0.1s;
            transform-origin: bottom right;
            /* Prevent jumping by ensuring consistent dimensions */
            min-height: 56px;
        }

        .assistant {
            align-self: flex-start;
            background-color: #ffffff;
            border-radius: 48px;
            border: none;
            animation-delay: 0.3s;
            transform-origin: bottom left;
            /* Prevent jumping by ensuring consistent dimensions */
            min-height: 56px;
            /* Smooth fade-in/out for background color changes */
            transition: background-color 0.4s ease, transform 0.3s ease;
        }

        .input-area {
            display: flex;
            gap: 10px;
            padding: 20px 0;
            position: sticky;
            bottom: 0;
            margin-top: auto;
            width: 100%;
        }

        .input-status-bar {
            width: 100%;
            height: 3px;
            margin: 0;
            background: transparent;
            overflow: hidden;
            position: relative;
            transition: background 0.2s;
            box-sizing: border-box;
            display: block;
        }
        .input-status-bar-progress {
            height: 100%;
            width: 0%;
            background-color: #2196f3;
            transition: width 0.2s linear;
            position: absolute;
            left: 0;
            top: 0;
            box-shadow: 0 0 3px rgba(33, 150, 243, 0.4);
        }
        

        .input-area textarea {
            flex-grow: 1;
            padding: 15px 28px;
            border: 1px solid #ddd;
            border-radius: 999px;
            resize: none;
            height: 54px;
            font-size: 16px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.05);
            transition: border-color 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease;
            backface-visibility: hidden;
        }
        
        .input-area textarea::placeholder {
            color: #999;
            font-family: 'Supreme', sans-serif;
            font-weight: 200;
        }
        
        .input-area textarea:focus {
            outline: none;
            border-color: #2196f3;
            box-shadow: 0 2px 8px rgba(33,150,243,0.2);
            transform: translateY(-1px);
            animation: softGlow 3s infinite ease-in-out;
        }

        .input-area button {
            width: 54px;
            height: 54px;
            padding: 0;
            background-color: #2196f3;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s, transform 0.2s, box-shadow 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        /* Send button glow animation removed */

        /* Circular loader removed */
        
        button {
            padding: 10px 20px;
            background-color: #2196f3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s;
        }

        .input-area button:hover {
            background-color: #0b7dda;
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(33, 150, 243, 0.3);
            animation: pulse 1s infinite ease-in-out;
        }
        
        .input-area button:active {
            transform: scale(0.95);
            box-shadow: 0 0 5px rgba(33, 150, 243, 0.1);
            animation: none;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 8px rgba(33, 150, 243, 0.2); }
            50% { box-shadow: 0 0 15px rgba(33, 150, 243, 0.4); }
            100% { box-shadow: 0 0 8px rgba(33, 150, 243, 0.2); }
        }

        button:hover {
            background-color: #0b7dda;
        }

        button:disabled {
            background-color: #b0bec5;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            text-align: center;
            color: #666;
            margin-top: 10px;
            font-style: italic;
        }

        /* Loading spinner removed */

        .typing-indicator {
            position: relative;
            align-self: flex-start;
            margin: 15px 0 0 24px;
            width: 30px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeInTyping 0.4s ease forwards;
            background: transparent;
            z-index: 1;
            transform-origin: left center;
            box-sizing: border-box;
            will-change: opacity, transform;
            border-radius: 24px;
        }
        
        @keyframes fadeInTyping {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }

        .typing-indicator span {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: rgba(33, 150, 243, 0.7);
            border-radius: 50%;
            display: block;
            animation: pulse-typing 2s infinite cubic-bezier(0.25, 0.1, 0.25, 1);
            box-shadow: 0 0 8px rgba(33, 150, 243, 0.3);
        }

        .typing-indicator span:before,
        .typing-indicator span:after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(33, 150, 243, 0.3);
            border-radius: 50%;
            z-index: -1;
            transform: scale(1);
            opacity: 1;
            animation: pulse-rings 2s infinite cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        .typing-indicator span:after {
            animation-delay: 0.4s;
        }

        @keyframes pulse-typing {
            0% { transform: scale(0.7); opacity: 0.5; }
            50% { transform: scale(1); opacity: 0.8; }
            100% { transform: scale(0.7); opacity: 0.5; }
        }
        
        @keyframes pulse-rings {
            0% { transform: scale(1); opacity: 0.8; }
            100% { transform: scale(2.5); opacity: 0; }
        }
        
        @keyframes pulse-rings {
            0% { transform: scale(1); opacity: 0.3; }
            100% { transform: scale(2); opacity: 0; }
        }

        pre {
            background-color: #2d2d2d; /* Darker background for code blocks */
            color: #f8f8f2; /* Light text for contrast */
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 10px 0;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            white-space: pre-wrap; /* Wrap long lines */
            word-wrap: break-word; /* Break long words */
        }

        code {
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em; /* Slightly smaller for inline code */
            background-color: #e0e0e0; /* Light grey for inline code */
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        /* For code within pre blocks, ensure it inherits pre's color */
        pre code {
            background-color: transparent;
            padding: 0;
            border-radius: 0;
            color: inherit; 
        }


        .error {
            color: #d32f2f;
            margin-top: 5px;
            font-weight: bold;
        }

        .hidden {
            display: none !important;
        }

        /* Full height for chat container */
        .chat-container {
            height: calc(100vh - 20px);
        }

        /* API key status dot animation */
        #api-key-dot {
            transition: background 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease, opacity 0.3s ease;
            position: relative;
        }

        #api-key-dot.loading {
            background-color: #aaa;
            animation: pulse-dot-loading 1.5s infinite ease-in-out;
        }
        
        #api-key-dot.valid {
            background-color: #2ecc40;
            animation: none;
            box-shadow: 0 0 6px rgba(46, 204, 64, 0.4);
        }
        
        #api-key-dot.valid::before,
        #api-key-dot.valid::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-color: rgba(46, 204, 64, 0.4);
            transform: translate(-50%, -50%) scale(1);
            z-index: -1;
            animation: radar-pulse 2.5s infinite cubic-bezier(0.25, 0.1, 0.25, 1);
            opacity: 0.7;
        }
        
        #api-key-dot.valid::after {
            animation-delay: 1.25s;
        }

        @keyframes pulse-dot-loading {
            0% { transform: scale(0.9); opacity: 0.5; }
            50% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0.9); opacity: 0.5; }
        }
        
        @keyframes radar-pulse {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 0.7; }
            100% { transform: translate(-50%, -50%) scale(3); opacity: 0; }
        }

        /* Responsive styles for mobile */            @media (max-width: 768px) {
                .api-key-container {
                    padding: 8px 10px;
                    gap: 6px;
                }
                
                .api-key-container input {
                    min-width: 140px;
                }
                
                .help-icon {
                    width: 16px;
                    height: 16px;
                    font-size: 10px;
                }
                
                .message {
                    max-width: 90%;
                }
                
                .chat-container {
                    padding: 15px 10px;
                }
                
                .input-area {
                    padding: 15px 0;
                    width: 100%;
                }
                
                .input-status-bar {
                    width: 100%;
                    height: 3px;
                }
            }

        /* Simple progress bar below the chat input - hidden but kept for future use */
        .progress-container {
            width: 100%;
            height: 4px;
            background-color: #f0f0f0;
            border-radius: 2px;
            margin-bottom: 10px;
            overflow: hidden;
            display: none; /* Hidden by default */
        }
        .progress-container.visible {
            display: block;
        }
        .progress-bar {
            height: 100%;
            background-color: #2196f3;
            width: 0%;
            transition: width 0.1s linear;
            border-radius: 2px;
        }
        .input-area {
            position: relative;
            width: 100%;
        }
    </style>
</head>
<body>
    <!-- API Key Update UI -->
    <div class="api-key-container">
        <input type="text" id="api-key-input" placeholder="Enter OpenRouter API key" autocomplete="off" />
        <span id="api-key-status" style="display:flex;align-items:center;margin:0 0 0 8px;"><span id="api-key-dot" style="display:inline-block;width:13px;height:13px;border-radius:50%;background:#aaa;"></span></span>
        <a href="https://openrouter.ai/docs/faq" target="_blank" class="api-key-link" title="How to get a key" style="display:flex;align-items:center;margin:0 0 0 8px;text-decoration:none;"><span class="help-icon" style="display:inline-flex;justify-content:center;align-items:center;width:15px;height:15px;font-size:11px;border-radius:50%;background:#e9e9e9;color:#555;box-shadow:0 1px 2px rgba(0,0,0,0.04);font-weight:500;letter-spacing:0.2px;text-decoration:none;">?</span></a>
    </div>

    <div id="chat-container" class="chat-container" style="margin-top:8px; height: calc(100vh - 60px); display: flex; flex-direction: column;">
        <div class="input-status-bar" id="input-status-bar" style="position: fixed; top: 0; left: 0; width: 100%; z-index: 100;">
            <div class="input-status-bar-progress" id="input-status-bar-progress"></div>
        </div>
        <div class="messages" id="llm-messages" style="flex-grow: 1; overflow-y: auto;">
            <!-- Welcome message removed -->
        </div>
        <div class="input-area">
            <textarea id="llm-user-input" placeholder="Design with words..."></textarea>
            <button id="llm-send-button" title="Send">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="send-icon">
                  <polyline points="6 15 12 9 18 15" />
                </svg>
                <span class="send-ripple"></span>
            </button>
            
            <style>
                .send-icon {
                    position: relative;
                    z-index: 2;
                    transition: transform 0.3s ease;
                }
                
                .send-ripple {
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%) scale(0);
                    width: 54px;
                    height: 54px;
                    background: rgba(255, 255, 255, 0.3);
                    border-radius: 50%;
                    z-index: 1;
                }
                
                #llm-send-button:active .send-ripple {
                    animation: ripple 0.6s linear;
                }
                
                @keyframes ripple {
                    0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
                    100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
                }
            </style>
        </div>
        <div class="progress-container" id="progress-container">
            <div class="progress-bar" id="progress-bar"></div>
        </div>
        <!-- Progress bar will be moved inside .input-area -->
        <p class="status" id="llm-status"></p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Removed hover effects and bubble animations to keep the UI clean and minimal
            
            // API Key update logic
            const apiKeyInput = document.getElementById('api-key-input');
            // Remove Save Key button from DOM and logic for minimal UI
            // Save Key button logic fully removed for minimal UI
            const apiKeyStatus = document.getElementById('api-key-status');
            const apiKeyDot = document.getElementById('api-key-dot');

            function setApiKeyStatus(color) {
                apiKeyDot.classList.remove('loading'); // Remove loading animation
                apiKeyDot.classList.remove('valid'); // Remove valid class
                apiKeyDot.style.background = color;
                
                // Add 'valid' class when the color is green (valid API key)
                if (color === '#2ecc40') {
                    apiKeyDot.classList.add('valid');
                }
            }

            // Set initial state (gray dot)
            setApiKeyStatus('#aaa');

            // Improved: Auto-connect and send hidden hello on valid API key
            let apiKeyValid = false;
            let apiKeyCheckTimeout = null;
            let lastApiKey = '';
            let helloSentForKey = {};
            
            // Disable the chat input and send button until a valid API key is provided
            document.getElementById('llm-user-input').disabled = true;
            document.getElementById('llm-send-button').disabled = true;
            
            // Function to mask API key with asterisks
            function maskApiKey() {
                // Only mask if there's actual content
                if (apiKeyInput.value.trim()) {
                    // Store current selection positions
                    const start = apiKeyInput.selectionStart;
                    const end = apiKeyInput.selectionEnd;
                    // Change to password type
                    apiKeyInput.type = 'password';
                    // Apply lighter color to masked text
                    apiKeyInput.style.color = '#999';
                    // Restore selection
                    apiKeyInput.setSelectionRange(start, end);
                } else {
                    // If empty, show as text field
                    apiKeyInput.type = 'text';
                    // Reset to default color
                    apiKeyInput.style.color = '';
                }
            }
            
            apiKeyInput.addEventListener('input', function() {
                const key = apiKeyInput.value.trim();
                
                // Immediately mask the API key
                maskApiKey();
                
                if (!key) {
                    setApiKeyStatus('#aaa');
                    apiKeyValid = false;
                    lastApiKey = '';
                    llmSendButton.disabled = true;
                    document.getElementById('llm-user-input').disabled = true;
                    return;
                }
                
                // Show loading animation
                apiKeyDot.classList.add('loading');
                llmSendButton.disabled = true;
                
                if (apiKeyCheckTimeout) clearTimeout(apiKeyCheckTimeout);
                apiKeyCheckTimeout = setTimeout(async () => {
                    try {
                        // First, update the backend with the key (for bridge logic)
                        const response = await fetch('/api/update-api-key', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ apiKey: key })
                        });
                        const data = await response.json();
                        if (response.ok && data.success) {
                            // Now, actually test the key by sending a real LLM request
                            try {
                                const helloResponse = await fetch('http://localhost:3002/llm-agent', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ prompt: 'hello', apiKey: key })
                                });
                                if (helloResponse.ok) {
                                    const helloData = await helloResponse.json();
                                    // Only set as valid if we get a real message back
                                    if (helloData && helloData.message) {
                                        setApiKeyStatus('#2ecc40');
                                        apiKeyValid = true;
                                        // Enable the send button when API key is valid
                                        llmSendButton.disabled = false;
                                        document.getElementById('llm-user-input').disabled = false;
                                        apiKeyValid = true;
                                        llmSendButton.disabled = false;
                                        // Enable the chat input field now that we have a valid API key
                                        document.getElementById('llm-user-input').disabled = false;
                                        // Only show hello if not already shown for this key
                                        if (!helloSentForKey[key]) {
                                            helloSentForKey[key] = true;
                                            lastApiKey = key;
                                            addMessageToUI(llmMessagesContainer, 'assistant', helloData.message);
                                        }
                                    } else {
                                        setApiKeyStatus('#d32f2f');
                                        // Keep masked even on error
                                        apiKeyValid = false;
                                        lastApiKey = '';
                                        llmSendButton.disabled = true;
                                        // Disable the chat input field on invalid API key
                                        document.getElementById('llm-user-input').disabled = true;
                                    }
                                } else {
                                    // LLM endpoint returned error (401, 403, etc)
                                    setApiKeyStatus('#d32f2f');
                                    // Keep masked even on error
                                    apiKeyValid = false;
                                    lastApiKey = '';
                                    llmSendButton.disabled = true;
                                }
                            } catch (e) {
                                setApiKeyStatus('#d32f2f');
                                // Keep masked even on error
                                apiKeyValid = false;
                                lastApiKey = '';
                                llmSendButton.disabled = true;
                            }
                        } else {
                            setApiKeyStatus('#d32f2f');
                            // Keep masked even on error
                            apiKeyValid = false;
                            lastApiKey = '';
                            llmSendButton.disabled = true;
                        }
                    } catch (err) {
                        setApiKeyStatus('#d32f2f');
                        // Keep masked even on error
                        apiKeyValid = false;
                        lastApiKey = '';
                        llmSendButton.disabled = true;
                    }
                }, 400); // debounce
            });
            // LLM agent chat
            const llmUserInput = document.getElementById('llm-user-input');
            const llmSendButton = document.getElementById('llm-send-button');
            const llmMessagesContainer = document.getElementById('llm-messages');
            const llmStatusElement = document.getElementById('llm-status');

            function escapeHtml(unsafe) {
                if (unsafe === undefined || unsafe === null) return '';
                if (typeof unsafe !== 'string') unsafe = String(unsafe);
                return unsafe
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            }

            function formatMessageContent(content) {
                // Escape HTML and format code blocks
                let escapedContent = escapeHtml(content);
                escapedContent = escapedContent.replace(/```([a-zA-Z0-9\+\-]*)\n?([\s\S]*?)```/g, 
                    function(match, language, code) {
                        return `<pre><code class="language-${language || 'plaintext'}">${code.trim()}</code></pre>`;
                    }
                );
                escapedContent = escapedContent.replace(/`([^`]+)`/g, '<code>$1</code>');
                return escapedContent;
            }

            function addMessageToUI(container, role, content) {
    const messageDiv = document.createElement('div');
    messageDiv.classList.add('message', role);
    
    // Different handling based on message role
    if (role === 'assistant') {
        // For assistant messages, prepare for letter-by-letter animation
        messageDiv.innerHTML = ''; // Start empty
        container.appendChild(messageDiv);
        
        // Animate text appearing letter by letter
        const formattedContent = formatMessageContent(content);
        let tempDiv = document.createElement('div');
        tempDiv.innerHTML = formattedContent;
        
        // Handle code blocks and regular text differently
        const nodes = Array.from(tempDiv.childNodes);
        let charIndex = 0;
        let currentNode = 0;
        
        // Create a recursive function to process nodes
        function processNode(node, parentElement) {
            if (node.nodeType === Node.TEXT_NODE) {
                // Text node - animate character by character
                const text = node.textContent;
                const textHolder = document.createTextNode('');
                parentElement.appendChild(textHolder);
                
                function animateText(index) {
                    if (index < text.length) {
                        textHolder.textContent += text[index];
                        setTimeout(() => animateText(index + 1), 5 + Math.random() * 10); // Slightly variable speed
                    } else if (currentNode < nodes.length - 1) {
                        // Move to next node when finished with this text
                        currentNode++;
                        processNode(nodes[currentNode], messageDiv);
                    }
                    // Scroll as text appears
                    container.scrollTop = container.scrollHeight;
                }
                
                if (charIndex === 0) {
                    // Start the animation for the first node
                    animateText(0);
                }
                charIndex++;
                
            } else if (node.nodeType === Node.ELEMENT_NODE) {
                // Element node (like <pre>, <code>, etc.)
                if (node.tagName === 'PRE') {
                    // Special handling for code blocks - add with subtle fade in
                    const clone = node.cloneNode(true);
                    clone.style.opacity = '0';
                    parentElement.appendChild(clone);
                    
                    // Simple fade-in for code blocks
                    setTimeout(() => {
                        clone.style.transition = 'opacity 0.8s ease';
                        clone.style.opacity = '1';
                    }, 100);
                    
                    // Continue with next node after code block is added
                    if (currentNode < nodes.length - 1) {
                        currentNode++;
                        setTimeout(() => {
                            processNode(nodes[currentNode], messageDiv);
                        }, 300);
                    }
                } else {
                    // Other elements - clone and process children
                    const clone = node.cloneNode(false);
                    parentElement.appendChild(clone);
                    
                    // Process child nodes
                    for (const child of node.childNodes) {
                        processNode(child, clone);
                    }
                }
            }
        }
        
        // Start processing nodes
        if (nodes.length > 0) {
            processNode(nodes[0], messageDiv);
        }
        
    } else {
        // For user messages, no animation needed
        messageDiv.innerHTML = formatMessageContent(content);
        container.appendChild(messageDiv);
    }
    
    // Always scroll to bottom
    setTimeout(() => {
        container.scrollTop = container.scrollHeight;
    }, 0);
            }

            // LLM agent chat logic
            async function sendLLMMessage() {
                const userMessageText = llmUserInput.value.trim();
                const apiKey = apiKeyInput.value.trim();
                if (!userMessageText) return;
                if (!apiKey || !apiKeyValid) {
                    llmStatusElement.innerHTML = `<span class="error">Please enter a valid OpenRouter API key above.</span>`;
                    // Focus on API key input to guide the user
                    apiKeyInput.focus();
                    return;
                }
                
                // Show status bar progress
                const statusBar = document.getElementById('input-status-bar');
                const statusBarProgress = document.getElementById('input-status-bar-progress');
                statusBar.style.background = '#f5f5f5'; // Light gray background for the status bar
                statusBarProgress.style.transition = 'none';
                statusBarProgress.style.width = '0%';
                void statusBarProgress.offsetWidth;
                statusBarProgress.style.transition = 'width 0.3s linear';
                const maxTimeout = 20000;
                let startTime = Date.now();
                let finished = false;
                function animateStatusBar() {
                    if (finished) return;
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min((elapsed / maxTimeout) * 100, 99.5);
                    statusBarProgress.style.width = progress + '%';
                    if (progress < 99.5) {
                        requestAnimationFrame(animateStatusBar);
                    }
                }
                animateStatusBar();

                addMessageToUI(llmMessagesContainer, 'user', userMessageText);
                llmUserInput.value = '';
                llmSendButton.disabled = true;
                llmUserInput.disabled = true;
                
                // Add only a spacing wrapper (no typing indicator animation)
                const indicatorWrapper = document.createElement('div');
                indicatorWrapper.style.minHeight = '30px';
                indicatorWrapper.style.position = 'relative';
                llmMessagesContainer.appendChild(indicatorWrapper);
                // Ensure smooth scrolling to the spacing wrapper
                setTimeout(() => {
                    llmMessagesContainer.scrollTo({
                        top: llmMessagesContainer.scrollHeight,
                        behavior: 'smooth'
                    });
                }, 50);
                
                try {
                    const response = await fetch('http://localhost:3002/llm-agent', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ prompt: userMessageText, apiKey })
                    });
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ error: { message: `HTTP error! status: ${response.status}` } }));
                        throw new Error(errorData.error?.message || `HTTP error! status: ${response.status}`);
                    }
                const data = await response.json();
                
                // Always show the LLM's message field (for both code and non-code responses)
                if (data.message) {
                    // Remove the indicatorWrapper (spacing) after response
                    if (indicatorWrapper.parentNode === llmMessagesContainer) {
                        llmMessagesContainer.removeChild(indicatorWrapper);
                    }
                    addMessageToUI(llmMessagesContainer, 'assistant', data.message);
                } else {
                    // fallback for legacy/edge cases
                    let code = data.code || '';
                    let printMessage = null;
                    let printMatch = code.match(/print\((['"])(.*?)\1\)/);
                    if (printMatch && printMatch[2]) {
                        printMessage = printMatch[2];
                    }
                    let blenderResult =
                        printMessage ||
                        data.blenderResult?.result ||
                        data.blenderResult?.message ||
                        data.blenderResult?.stdout ||
                        data.blenderResult?.output ||
                        data.result ||
                        '[No response from Blender]';
                    // Remove the indicatorWrapper (spacing) after response
                    if (indicatorWrapper.parentNode === llmMessagesContainer) {
                        llmMessagesContainer.removeChild(indicatorWrapper);
                    }
                    addMessageToUI(llmMessagesContainer, 'assistant', blenderResult);
                }
                // No status text for minimal UI
                } catch (error) {
                    console.error('Error in LLM/Blender flow:', error);
                    addMessageToUI(llmMessagesContainer, 'assistant', `Sorry, I encountered an error: ${escapeHtml(error.message)}`);
                } finally {
                    finished = true;
                    statusBarProgress.style.width = '100%';
                    setTimeout(() => {
                        statusBar.style.background = 'transparent';
                        statusBarProgress.style.transition = 'none';
                        statusBarProgress.style.width = '0%';
                        setTimeout(() => { statusBarProgress.style.transition = 'width 0.3s linear'; }, 50);
                        llmSendButton.disabled = false;
                        llmUserInput.disabled = false;
                        llmUserInput.focus();
                    }, 400);
                }
            }

            llmSendButton.addEventListener('click', sendLLMMessage);
            llmUserInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendLLMMessage();
                }
            });
            
            // Update the setApiKeyStatus function to handle the dot valid state
            const originalSetApiKeyStatus = setApiKeyStatus;
            setApiKeyStatus = function(color) {
                originalSetApiKeyStatus(color);
                // Add 'valid' class when API key is valid (green)
                if (color === '#2ecc40') {
                    apiKeyDot.classList.add('valid');
                } else {
                    apiKeyDot.classList.remove('valid');
                }
            };
        });
    </script>
</body>
</html>
