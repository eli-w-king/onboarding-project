<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenRouter Chat</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #ffffff;
            display: flex;
            flex-direction: column;
            height: 100vh;
            position: relative;
            overflow: hidden;
        }

        /* Background animation - breathing pulse effect */
        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(231,242,255,0.2) 0%, rgba(255,255,255,0) 70%);
            z-index: -1;
            animation: breathePulse 8s ease-in-out infinite;
            opacity: 0.7;
        }

        @keyframes breathePulse {
            0% { opacity: 0.4; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
            100% { opacity: 0.4; transform: scale(1); }
        }
        
        /* Soft glow animation kept for input elements */
        @keyframes softGlow {
            0% { box-shadow: 0 0 5px rgba(33, 150, 243, 0.1); }
            50% { box-shadow: 0 0 15px rgba(33, 150, 243, 0.2); }
            100% { box-shadow: 0 0 5px rgba(33, 150, 243, 0.1); }
        }

        .api-key-container {
            background-color: transparent;
            padding: 8px 15px;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: nowrap;
            width: 100%;
            min-height: 48px;
        }
        
        @media (max-width: 600px) {
            .api-key-container {
                padding: 8px 10px;
                gap: 6px;
            }
            .api-key-container input {
                min-width: 0;
                font-size: 13px;
                width: 100%;
                padding: 12px 18px;
                height: 44px;
            }
        }

        .api-key-container input {
            flex-grow: 1;
            width: 100%;
            min-width: 0;
            max-width: none;
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 15px;
            box-shadow: none;
            transition: border-color 0.3s ease;
            text-align: left;
            box-sizing: border-box;
            height: 36px;
        }
        
        .api-key-container input::placeholder {
            text-align: left;
            color: #999;
        }
        
        .api-key-container input:focus {
            outline: none;
            border-color: #2196f3;
            box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.1);
        }
        
        .api-key-link {
            margin-left: 0;
            display: flex;
            align-items: center;
            height: 100%;
            padding-top: 0;
            padding-bottom: 0;
        }
        
        .help-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background-color: #2196f3;
            color: white;
            font-size: 12px;
            font-weight: bold;
            text-decoration: none;
            margin: 0;
        }
        
        .api-key-link:hover .help-icon {
            background-color: #0b7dda;
            transform: scale(1.1);
            transition: all 0.2s ease;
        }

        .model-selector {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            min-width: 200px;
        }

        .chat-container {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            overflow: hidden;
            max-width: 1000px;
            margin: 0 auto;
            width: 100%;
            padding: 20px;
            position: relative;
            overflow: hidden;
            background-color: transparent;
        }

        /* Chat border animation removed */

        .messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px 0;
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 0 5px;
        }

        .message {
            padding: 12px 24px;
            border-radius: 24px;
            max-width: 85%;
            word-break: break-word;
            line-height: 1.6;
            transition: all 0.5s cubic-bezier(0.25, 0.1, 0.25, 1);
            animation: messageFadeIn 0.5s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
            opacity: 0;
            will-change: opacity, transform;
            transform-style: preserve-3d;
            backface-visibility: hidden;
            /* Prevent layout shifts and improve rendering performance */
            contain: layout style;
        }

        @keyframes messageFadeIn {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .user {
            align-self: flex-end;
            background-color: #f9f9f9;
            border-radius: 24px;
            border: 1px solid #f0f0f0;
            animation-delay: 0.1s;
            transform-origin: bottom right;
            /* Prevent jumping by ensuring consistent dimensions */
            min-height: 24px;
        }

        .assistant {
            align-self: flex-start;
            background-color: #ffffff;
            border-radius: 24px;
            border: none;
            animation-delay: 0.3s;
            transform-origin: bottom left;
            /* Prevent jumping by ensuring consistent dimensions */
            min-height: 24px;
            /* Smooth fade-in/out for background color changes */
            transition: background-color 0.4s ease, transform 0.3s ease;
        }

        .input-area {
            display: flex;
            gap: 10px;
            padding: 20px 0;
            position: sticky;
            bottom: 0;
            margin-top: auto;
            width: 100%;
        }

        .input-status-bar {
            width: 100%;
            height: 4px;
            margin: 0 0 6px 0;
            background: #e3eaf3;
            border-radius: 2px;
            overflow: hidden;
            position: relative;
            transition: background 0.2s;
            box-sizing: border-box;
            display: block;
        }
        .input-status-bar-progress {
            height: 100%;
            width: 0%;
            background-color: #2196f3;
            border-radius: 2px;
            transition: width 0.2s linear;
            position: absolute;
            left: 0;
            top: 0;
        }
        

        .input-area textarea {
            flex-grow: 1;
            padding: 15px 28px;
            border: 1px solid #ddd;
            border-radius: 999px;
            resize: none;
            height: 54px;
            font-size: 16px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.05);
            transition: border-color 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease;
            backface-visibility: hidden;
        }
        
        .input-area textarea:focus {
            outline: none;
            border-color: #2196f3;
            box-shadow: 0 2px 8px rgba(33,150,243,0.2);
            transform: translateY(-1px);
            animation: softGlow 3s infinite ease-in-out;
        }

        .input-area button {
            width: 54px;
            height: 54px;
            padding: 0;
            background-color: #2196f3;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s, transform 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .circular-loader {
            width: 54px;
            height: 54px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 2;
        }
        .circular-loader svg {
            width: 54px;
            height: 54px;
            display: block;
        }
        .circular-loader .circle-bg {
            stroke: #e3eaf3;
        }
        .circular-loader .circle {
            stroke: #2196f3;
            stroke-width: 3.5;
            stroke-linecap: round;
            fill: none;
            stroke-dasharray: 157;
            stroke-dashoffset: 157;
            transition: stroke-dashoffset 0.3s linear;
        }
        
        button {
            padding: 10px 20px;
            background-color: #2196f3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s;
        }

        .input-area button:hover {
            background-color: #0b7dda;
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(33, 150, 243, 0.3);
            animation: pulse 1s infinite ease-in-out;
        }
        
        .input-area button:active {
            transform: scale(0.95);
            box-shadow: 0 0 5px rgba(33, 150, 243, 0.1);
            animation: none;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 8px rgba(33, 150, 243, 0.2); }
            50% { box-shadow: 0 0 15px rgba(33, 150, 243, 0.4); }
            100% { box-shadow: 0 0 8px rgba(33, 150, 243, 0.2); }
        }

        button:hover {
            background-color: #0b7dda;
        }

        button:disabled {
            background-color: #b0bec5;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            text-align: center;
            color: #666;
            margin-top: 10px;
            font-style: italic;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #2196f3;
            animation: spin 1s ease-in-out infinite;
            margin-left: 5px;
            vertical-align: middle;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .typing-indicator {
            position: relative;
            align-self: flex-start;
            margin: 15px 0 0 24px;
            width: 30px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeInTyping 0.4s ease forwards;
            background: transparent;
            z-index: 1;
            transform-origin: left center;
            box-sizing: border-box;
            will-change: opacity, transform;
            border-radius: 24px;
        }
        
        @keyframes fadeInTyping {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }

        .typing-indicator span {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: rgba(33, 150, 243, 0.7);
            border-radius: 50%;
            display: block;
            animation: pulse-typing 2s infinite cubic-bezier(0.25, 0.1, 0.25, 1);
            box-shadow: 0 0 8px rgba(33, 150, 243, 0.3);
        }

        .typing-indicator span:before,
        .typing-indicator span:after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(33, 150, 243, 0.3);
            border-radius: 50%;
            z-index: -1;
            transform: scale(1);
            opacity: 1;
            animation: pulse-rings 2s infinite cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        .typing-indicator span:after {
            animation-delay: 0.4s;
        }

        @keyframes pulse-typing {
            0% { transform: scale(0.7); opacity: 0.5; }
            50% { transform: scale(1); opacity: 0.8; }
            100% { transform: scale(0.7); opacity: 0.5; }
        }
        
        @keyframes pulse-rings {
            0% { transform: scale(1); opacity: 0.8; }
            100% { transform: scale(2.5); opacity: 0; }
        }
        
        @keyframes pulse-rings {
            0% { transform: scale(1); opacity: 0.3; }
            100% { transform: scale(2); opacity: 0; }
        }

        pre {
            background-color: #2d2d2d; /* Darker background for code blocks */
            color: #f8f8f2; /* Light text for contrast */
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 10px 0;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            white-space: pre-wrap; /* Wrap long lines */
            word-wrap: break-word; /* Break long words */
        }

        code {
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em; /* Slightly smaller for inline code */
            background-color: #e0e0e0; /* Light grey for inline code */
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        /* For code within pre blocks, ensure it inherits pre's color */
        pre code {
            background-color: transparent;
            padding: 0;
            border-radius: 0;
            color: inherit; 
        }


        .error {
            color: #d32f2f;
            margin-top: 5px;
            font-weight: bold;
        }

        .hidden {
            display: none !important;
        }

        /* Full height for chat container */
        .chat-container {
            height: calc(100vh - 20px);
        }

        /* API key status dot animation */
        #api-key-dot {
            transition: background 0.3s ease, box-shadow 0.3s ease;
        }

        #api-key-dot.loading {
            background: conic-gradient(#2563eb 0% 30%, #60a5fa 30% 60%, #e0edff 60% 100%);
            animation: spin-dot 0.8s linear infinite;
            box-shadow: 0 0 6px rgba(96, 165, 250, 0.5);
        }

        @keyframes spin-dot {
            100% { transform: rotate(360deg); }
        }

        /* Responsive styles for mobile */
        @media (max-width: 768px) {
            .api-key-container {
                padding: 8px 10px;
                gap: 6px;
            }
            
            .api-key-container input {
                min-width: 140px;
            }
            
            .help-icon {
                width: 16px;
                height: 16px;
                font-size: 10px;
            }
            
            .message {
                max-width: 90%;
            }
            
            .chat-container {
                padding: 15px 10px;
            }
            
            .input-area {
                padding: 15px 0;
                width: 100%;
            }
            
            .input-status-bar {
                width: 100%;
                margin: 0 0 6px 0;
            }
        }

        /* Simple progress bar below the chat input - hidden but kept for future use */
        .progress-container {
            width: 100%;
            height: 4px;
            background-color: #f0f0f0;
            border-radius: 2px;
            margin-bottom: 10px;
            overflow: hidden;
            display: none; /* Hidden by default */
        }
        .progress-container.visible {
            display: block;
        }
        .progress-bar {
            height: 100%;
            background-color: #2196f3;
            width: 0%;
            transition: width 0.1s linear;
            border-radius: 2px;
        }
        .input-area {
            position: relative;
            width: 100%;
        }
    </style>
</head>
<body>
    <!-- API Key Update UI -->
    <div class="api-key-container">
        <input type="text" id="api-key-input" placeholder="Enter OpenRouter API key" autocomplete="off" />
        <span id="api-key-status" style="display:flex;align-items:center;margin:0 0 0 8px;"><span id="api-key-dot" style="display:inline-block;width:13px;height:13px;border-radius:50%;background:#aaa;"></span></span>
        <a href="https://openrouter.ai/docs/faq" target="_blank" class="api-key-link" title="How to get a key" style="display:flex;align-items:center;margin:0 0 0 8px;text-decoration:none;"><span class="help-icon" style="display:inline-flex;justify-content:center;align-items:center;width:15px;height:15px;font-size:11px;border-radius:50%;background:#e9e9e9;color:#555;box-shadow:0 1px 2px rgba(0,0,0,0.04);font-weight:500;letter-spacing:0.2px;text-decoration:none;">?</span></a>
    </div>

    <div id="chat-container" class="chat-container" style="margin-top:8px; height: calc(100vh - 60px); display: flex; flex-direction: column;">
        <div class="messages" id="llm-messages" style="flex-grow: 1; overflow-y: auto;">
            <!-- Welcome message removed -->
        </div>
        <div class="input-status-bar" id="input-status-bar" style="width:100%;">
            <div class="input-status-bar-progress" id="input-status-bar-progress"></div>
        </div>
        <div class="input-area">
            <textarea id="llm-user-input" placeholder="Design with words..."></textarea>
            <button id="llm-send-button" title="Send">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="send-icon">
                  <polyline points="6 15 12 9 18 15" />
                </svg>
                <span class="send-ripple"></span>
            </button>
            
            <style>
                .send-icon {
                    position: relative;
                    z-index: 2;
                    transition: transform 0.3s ease;
                }
                
                .send-ripple {
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%) scale(0);
                    width: 54px;
                    height: 54px;
                    background: rgba(255, 255, 255, 0.3);
                    border-radius: 50%;
                    z-index: 1;
                }
                
                #llm-send-button:active .send-ripple {
                    animation: ripple 0.6s linear;
                }
                
                @keyframes ripple {
                    0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
                    100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
                }
            </style>
        </div>
        <div class="progress-container" id="progress-container">
            <div class="progress-bar" id="progress-bar"></div>
        </div>
        <!-- Progress bar will be moved inside .input-area -->
        <p class="status" id="llm-status"></p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Removed hover effects and bubble animations to keep the UI clean and minimal
            
            // API Key update logic
            const apiKeyInput = document.getElementById('api-key-input');
            // Remove Save Key button from DOM and logic for minimal UI
            // Save Key button logic fully removed for minimal UI
            const apiKeyStatus = document.getElementById('api-key-status');
            const apiKeyDot = document.getElementById('api-key-dot');

            function setApiKeyStatus(color) {
                apiKeyDot.classList.remove('loading'); // Remove loading animation
                apiKeyDot.style.background = color;
            }

            // Set initial state (gray dot)
            setApiKeyStatus('#aaa');

            // Improved: Auto-connect and send hidden hello on valid API key
            let apiKeyValid = false;
            let apiKeyCheckTimeout = null;
            let lastApiKey = '';
            let helloSentForKey = {};
            
            // Disable the chat input until a valid API key is provided
            document.getElementById('llm-user-input').disabled = true;
            
            // Function to mask API key with asterisks
            function maskApiKey() {
                // Only mask if there's actual content
                if (apiKeyInput.value.trim()) {
                    // Store current selection positions
                    const start = apiKeyInput.selectionStart;
                    const end = apiKeyInput.selectionEnd;
                    // Change to password type
                    apiKeyInput.type = 'password';
                    // Apply lighter color to masked text
                    apiKeyInput.style.color = '#999';
                    // Restore selection
                    apiKeyInput.setSelectionRange(start, end);
                } else {
                    // If empty, show as text field
                    apiKeyInput.type = 'text';
                    // Reset to default color
                    apiKeyInput.style.color = '';
                }
            }
            
            apiKeyInput.addEventListener('input', function() {
                const key = apiKeyInput.value.trim();
                
                // Immediately mask the API key
                maskApiKey();
                
                if (!key) {
                    setApiKeyStatus('#aaa');
                    apiKeyValid = false;
                    lastApiKey = '';
                    llmSendButton.disabled = true;
                    document.getElementById('llm-user-input').disabled = true;
                    return;
                }
                
                // Show loading animation
                apiKeyDot.classList.add('loading');
                llmSendButton.disabled = true;
                
                if (apiKeyCheckTimeout) clearTimeout(apiKeyCheckTimeout);
                apiKeyCheckTimeout = setTimeout(async () => {
                    try {
                        // First, update the backend with the key (for bridge logic)
                        const response = await fetch('/api/update-api-key', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ apiKey: key })
                        });
                        const data = await response.json();
                        if (response.ok && data.success) {
                            // Now, actually test the key by sending a real LLM request
                            try {
                                const helloResponse = await fetch('http://localhost:3002/llm-agent', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ prompt: 'hello', apiKey: key })
                                });
                                if (helloResponse.ok) {
                                    const helloData = await helloResponse.json();
                                    // Only set as valid if we get a real message back
                                    if (helloData && helloData.message) {
                                        setApiKeyStatus('#2ecc40');
                                        // Keep as password type
                                        apiKeyValid = true;
                                        llmSendButton.disabled = false;
                                        // Enable the chat input field now that we have a valid API key
                                        document.getElementById('llm-user-input').disabled = false;
                                        // Only show hello if not already shown for this key
                                        if (!helloSentForKey[key]) {
                                            helloSentForKey[key] = true;
                                            lastApiKey = key;
                                            addMessageToUI(llmMessagesContainer, 'assistant', helloData.message);
                                        }
                                    } else {
                                        setApiKeyStatus('#d32f2f');
                                        // Keep masked even on error
                                        apiKeyValid = false;
                                        lastApiKey = '';
                                        llmSendButton.disabled = true;
                                        // Disable the chat input field on invalid API key
                                        document.getElementById('llm-user-input').disabled = true;
                                    }
                                } else {
                                    // LLM endpoint returned error (401, 403, etc)
                                    setApiKeyStatus('#d32f2f');
                                    // Keep masked even on error
                                    apiKeyValid = false;
                                    lastApiKey = '';
                                    llmSendButton.disabled = true;
                                }
                            } catch (e) {
                                setApiKeyStatus('#d32f2f');
                                // Keep masked even on error
                                apiKeyValid = false;
                                lastApiKey = '';
                                llmSendButton.disabled = true;
                            }
                        } else {
                            setApiKeyStatus('#d32f2f');
                            // Keep masked even on error
                            apiKeyValid = false;
                            lastApiKey = '';
                            llmSendButton.disabled = true;
                        }
                    } catch (err) {
                        setApiKeyStatus('#d32f2f');
                        // Keep masked even on error
                        apiKeyValid = false;
                        lastApiKey = '';
                        llmSendButton.disabled = true;
                    }
                }, 400); // debounce
            });
            // LLM agent chat
            const llmUserInput = document.getElementById('llm-user-input');
            const llmSendButton = document.getElementById('llm-send-button');
            const llmMessagesContainer = document.getElementById('llm-messages');
            const llmStatusElement = document.getElementById('llm-status');

            function escapeHtml(unsafe) {
                if (unsafe === undefined || unsafe === null) return '';
                if (typeof unsafe !== 'string') unsafe = String(unsafe);
                return unsafe
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            }

            function formatMessageContent(content) {
                // Escape HTML and format code blocks
                let escapedContent = escapeHtml(content);
                escapedContent = escapedContent.replace(/```([a-zA-Z0-9\+\-]*)\n?([\s\S]*?)```/g, 
                    function(match, language, code) {
                        return `<pre><code class="language-${language || 'plaintext'}">${code.trim()}</code></pre>`;
                    }
                );
                escapedContent = escapedContent.replace(/`([^`]+)`/g, '<code>$1</code>');
                return escapedContent;
            }

            function addMessageToUI(container, role, content) {
    const messageDiv = document.createElement('div');
    messageDiv.classList.add('message', role);
    
    // Different handling based on message role
    if (role === 'assistant') {
        // For assistant messages, prepare for letter-by-letter animation
        messageDiv.innerHTML = ''; // Start empty
        container.appendChild(messageDiv);
        
        // Animate text appearing letter by letter
        const formattedContent = formatMessageContent(content);
        let tempDiv = document.createElement('div');
        tempDiv.innerHTML = formattedContent;
        
        // Handle code blocks and regular text differently
        const nodes = Array.from(tempDiv.childNodes);
        let charIndex = 0;
        let currentNode = 0;
        
        // Create a recursive function to process nodes
        function processNode(node, parentElement) {
            if (node.nodeType === Node.TEXT_NODE) {
                // Text node - animate character by character
                const text = node.textContent;
                const textHolder = document.createTextNode('');
                parentElement.appendChild(textHolder);
                
                function animateText(index) {
                    if (index < text.length) {
                        textHolder.textContent += text[index];
                        setTimeout(() => animateText(index + 1), 5 + Math.random() * 10); // Slightly variable speed
                    } else if (currentNode < nodes.length - 1) {
                        // Move to next node when finished with this text
                        currentNode++;
                        processNode(nodes[currentNode], messageDiv);
                    }
                    // Scroll as text appears
                    container.scrollTop = container.scrollHeight;
                }
                
                if (charIndex === 0) {
                    // Start the animation for the first node
                    animateText(0);
                }
                charIndex++;
                
            } else if (node.nodeType === Node.ELEMENT_NODE) {
                // Element node (like <pre>, <code>, etc.)
                if (node.tagName === 'PRE') {
                    // Special handling for code blocks - add with subtle fade in
                    const clone = node.cloneNode(true);
                    clone.style.opacity = '0';
                    parentElement.appendChild(clone);
                    
                    // Simple fade-in for code blocks
                    setTimeout(() => {
                        clone.style.transition = 'opacity 0.8s ease';
                        clone.style.opacity = '1';
                    }, 100);
                    
                    // Continue with next node after code block is added
                    if (currentNode < nodes.length - 1) {
                        currentNode++;
                        setTimeout(() => {
                            processNode(nodes[currentNode], messageDiv);
                        }, 300);
                    }
                } else {
                    // Other elements - clone and process children
                    const clone = node.cloneNode(false);
                    parentElement.appendChild(clone);
                    
                    // Process child nodes
                    for (const child of node.childNodes) {
                        processNode(child, clone);
                    }
                }
            }
        }
        
        // Start processing nodes
        if (nodes.length > 0) {
            processNode(nodes[0], messageDiv);
        }
        
    } else {
        // For user messages, no animation needed
        messageDiv.innerHTML = formatMessageContent(content);
        container.appendChild(messageDiv);
    }
    
    // Always scroll to bottom
    setTimeout(() => {
        container.scrollTop = container.scrollHeight;
    }, 0);
            }

            // LLM agent chat logic
            async function sendLLMMessage() {
                const userMessageText = llmUserInput.value.trim();
                const apiKey = apiKeyInput.value.trim();
                if (!userMessageText) return;
                if (!apiKey || !apiKeyValid) {
                    llmStatusElement.innerHTML = `<span class="error">Please enter a valid OpenRouter API key above.</span>`;
                    // Focus on API key input to guide the user
                    apiKeyInput.focus();
                    return;
                }
                
                // Show status bar progress
                const statusBar = document.getElementById('input-status-bar');
                const statusBarProgress = document.getElementById('input-status-bar-progress');
                statusBarProgress.style.transition = 'none';
                statusBarProgress.style.width = '0%';
                void statusBarProgress.offsetWidth;
                statusBarProgress.style.transition = 'width 0.3s linear';
                const maxTimeout = 20000;
                let startTime = Date.now();
                let finished = false;
                function animateStatusBar() {
                    if (finished) return;
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min((elapsed / maxTimeout) * 100, 99.5);
                    statusBarProgress.style.width = progress + '%';
                    if (progress < 99.5) {
                        requestAnimationFrame(animateStatusBar);
                    }
                }
                animateStatusBar();

                addMessageToUI(llmMessagesContainer, 'user', userMessageText);
                llmUserInput.value = '';
                llmSendButton.disabled = true;
                llmUserInput.disabled = true;
                
                // Add typing indicator - now a pulsing circle with improved positioning
                const typingIndicator = document.createElement('div');
                typingIndicator.className = 'typing-indicator';
                typingIndicator.innerHTML = '<span></span>';
                
                // Create a wrapper to ensure consistent spacing
                const indicatorWrapper = document.createElement('div');
                indicatorWrapper.style.minHeight = '30px';
                indicatorWrapper.style.position = 'relative';
                indicatorWrapper.appendChild(typingIndicator);
                
                llmMessagesContainer.appendChild(indicatorWrapper);
                
                // Ensure smooth scrolling to the typing indicator
                setTimeout(() => {
                    llmMessagesContainer.scrollTo({
                        top: llmMessagesContainer.scrollHeight,
                        behavior: 'smooth'
                    });
                }, 50);
                
                try {
                    const response = await fetch('http://localhost:3002/llm-agent', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ prompt: userMessageText, apiKey })
                    });
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ error: { message: `HTTP error! status: ${response.status}` } }));
                        throw new Error(errorData.error?.message || `HTTP error! status: ${response.status}`);
                    }
                const data = await response.json();
                
                // Get the typing indicator and its wrapper for a fluid transition
                const typingIndicator = llmMessagesContainer.querySelector('.typing-indicator');
                const typingIndicatorWrapper = typingIndicator ? typingIndicator.parentNode : null;
                
                // Always show the LLM's message field (for both code and non-code responses)
                if (data.message) {
                    // Create the message div that will contain the text
                    const messageDiv = document.createElement('div');
                    messageDiv.classList.add('message', 'assistant');
                    messageDiv.style.opacity = '0';
                    
                    // Get the position of the typing indicator for a seamless transition
                    const indicatorRect = typingIndicator ? typingIndicator.getBoundingClientRect() : null;
                    const containerRect = llmMessagesContainer.getBoundingClientRect();
                    
                    // Create a placeholder to maintain scrolling position
                    const placeholderDiv = document.createElement('div');
                    placeholderDiv.style.height = typingIndicatorWrapper ? `${typingIndicatorWrapper.offsetHeight}px` : '30px';
                    placeholderDiv.style.opacity = '0';
                    placeholderDiv.style.pointerEvents = 'none';
                    
                    // Position the message div at the typing indicator's location
                    if (indicatorRect && typingIndicatorWrapper) {
                        messageDiv.style.position = 'absolute';
                        messageDiv.style.left = '24px'; // Match the typing indicator margin-left
                        messageDiv.style.top = (indicatorRect.top - containerRect.top) + 'px';
                        messageDiv.style.paddingLeft = '24px'; // Match horizontal padding of oval shape
                        messageDiv.style.background = 'none';
                        messageDiv.style.minHeight = `${typingIndicatorWrapper.offsetHeight}px`;
                        messageDiv.style.margin = '15px 0 0 0';
                        messageDiv.style.borderRadius = '24px';
                        
                        // Add placeholder where typing indicator was to prevent content jumping
                        llmMessagesContainer.insertBefore(placeholderDiv, typingIndicatorWrapper);
                    }
                    
                    // Append the message div
                    llmMessagesContainer.appendChild(messageDiv);
                    
                    // Add a minimal delay to start the transition
                    setTimeout(() => {
                        // Fade out typing indicator gradually as text appears
                        if (typingIndicator && typingIndicatorWrapper) {
                            typingIndicator.style.transition = 'opacity 0.6s ease, transform 0.6s ease';
                            typingIndicator.style.opacity = '0';
                            typingIndicator.style.transform = 'scale(0.5)';
                            
                            // Remove only after text starts appearing
                            setTimeout(() => {
                                // Remove the wrapper containing the typing indicator
                                if (typingIndicatorWrapper.parentNode === llmMessagesContainer) {
                                    llmMessagesContainer.removeChild(typingIndicatorWrapper);
                                }
                                
                                // Remove placeholder after transition is complete with a smoother animation
                                if (placeholderDiv.parentNode) {
                                    // Save the current scroll position
                                    const scrollPos = llmMessagesContainer.scrollTop;
                                    
                                    placeholderDiv.style.transition = 'height 0.4s cubic-bezier(0.25, 0.1, 0.25, 1), opacity 0.4s cubic-bezier(0.25, 0.1, 0.25, 1)';
                                    placeholderDiv.style.height = '0';
                                    
                                    // Restore scroll position to prevent jumping during removal
                                    llmMessagesContainer.scrollTop = scrollPos;
                                    
                                    setTimeout(() => {
                                        if (placeholderDiv.parentNode) {
                                            placeholderDiv.parentNode.removeChild(placeholderDiv);
                                            
                                            // Final scroll position adjustment after all transitions
                                            llmMessagesContainer.scrollTo({
                                                top: llmMessagesContainer.scrollHeight,
                                                behavior: 'smooth'
                                            });
                                        }
                                    }, 400);
                                }
                            }, 600);
                        }
                        
                        // Start the text animation
                        const formattedContent = formatMessageContent(data.message);
                        let tempDiv = document.createElement('div');
                        tempDiv.innerHTML = formattedContent;
                        
                        // Prepare for animation with improved timing function
                        messageDiv.style.transition = 'all 0.8s cubic-bezier(0.19, 1, 0.22, 1)';
                        messageDiv.style.opacity = '1';
                        
                        // After first few characters appear, transition to normal message position
                        setTimeout(() => {
                            // Save the scroll position before changing layout
                            const scrollPos = llmMessagesContainer.scrollTop;
                            
                            messageDiv.style.position = 'relative';
                            messageDiv.style.top = 'auto';
                            messageDiv.style.left = 'auto';
                            messageDiv.style.padding = '12px 24px';
                            messageDiv.style.background = '#ffffff';
                            messageDiv.style.borderRadius = '24px';
                            
                            // Restore scroll position to prevent jumping
                            llmMessagesContainer.scrollTop = scrollPos;
                        }, 400);
                        
                        // Handle code blocks and regular text for animation with smoother scrolling
                        const nodes = Array.from(tempDiv.childNodes);
                        let charIndex = 0;
                        let currentNode = 0;
                        
                        // For smoother animation, pre-calculate approximate height
                        const textLength = data.message.length;
                        const estimatedLineCount = Math.ceil(textLength / 80); // Rough estimate of chars per line
                        const estimatedHeight = Math.max(50, estimatedLineCount * 24); // Approximate height in pixels
                        
                        // Pre-size the message div to prevent shifting
                        if (!messageDiv.style.minHeight) {
                            messageDiv.style.minHeight = `${Math.min(200, estimatedHeight)}px`;
                        }
                        
                        function processNode(node, parentElement) {
                            // Enhanced process function for smoother animations
                            if (node.nodeType === Node.TEXT_NODE) {
                                const text = node.textContent;
                                const textHolder = document.createTextNode('');
                                parentElement.appendChild(textHolder);
                                
                                // Maintain a consistent scroll position during animation
                                let lastScrollUpdate = 0;
                                
                                function animateText(index) {
                                    if (index < text.length) {
                                        textHolder.textContent += text[index];
                                        
                                        // Throttle scroll updates for performance
                                        const now = Date.now();
                                        if (now - lastScrollUpdate > 100) {
                                            lastScrollUpdate = now;
                                            // Smooth scroll only when near bottom
                                            const isNearBottom = llmMessagesContainer.scrollHeight - llmMessagesContainer.scrollTop - llmMessagesContainer.clientHeight < 50;
                                            if (isNearBottom) {
                                                llmMessagesContainer.scrollTo({
                                                    top: llmMessagesContainer.scrollHeight,
                                                    behavior: 'smooth'
                                                });
                                            }
                                        }
                                        
                                        // Variable speed based on character type for more natural typing
                                        let delay = 5;
                                        if ('.!?:;'.includes(text[index])) delay = 30; // Pause longer at punctuation
                                        else if (text[index] === ' ') delay = 15; // Slight pause at spaces
                                        else delay = 5 + Math.random() * 5; // Normal characters
                                        
                                        setTimeout(() => animateText(index + 1), delay);
                                    } else if (currentNode < nodes.length - 1) {
                                        currentNode++;
                                        processNode(nodes[currentNode], messageDiv);
                                    }
                                }
                                
                                if (charIndex === 0) {
                                    animateText(0);
                                }
                                charIndex++;
                                
                            } else if (node.nodeType === Node.ELEMENT_NODE) {
                                if (node.tagName === 'PRE') {
                                    const clone = node.cloneNode(true);
                                    clone.style.opacity = '0';
                                    parentElement.appendChild(clone);
                                    
                                    setTimeout(() => {
                                        clone.style.transition = 'opacity 0.8s ease';
                                        clone.style.opacity = '1';
                                    }, 100);
                                    
                                    if (currentNode < nodes.length - 1) {
                                        currentNode++;
                                        setTimeout(() => {
                                            processNode(nodes[currentNode], messageDiv);
                                        }, 300);
                                    }
                                } else {
                                    const clone = node.cloneNode(false);
                                    parentElement.appendChild(clone);
                                    
                                    for (const child of node.childNodes) {
                                        processNode(child, clone);
                                    }
                                }
                            }
                        }
                        
                        if (nodes.length > 0) {
                            processNode(nodes[0], messageDiv);
                        }
                    }, 200);
                } else {
                    // fallback for legacy/edge cases
                    let code = data.code || '';
                    let printMessage = null;
                    let printMatch = code.match(/print\((['"])(.*?)\1\)/);
                    if (printMatch && printMatch[2]) {
                        printMessage = printMatch[2];
                    }
                    let blenderResult =
                        printMessage ||
                        data.blenderResult?.result ||
                        data.blenderResult?.message ||
                        data.blenderResult?.stdout ||
                        data.blenderResult?.output ||
                        data.result ||
                        '[No response from Blender]';
                    
                    // Add a small delay for better UX
                    setTimeout(() => {
                        addMessageToUI(llmMessagesContainer, 'assistant', blenderResult);
                    }, 400);
                }
                // No status text for minimal UI
                } catch (error) {
                    console.error('Error in LLM/Blender flow:', error);
                    addMessageToUI(llmMessagesContainer, 'assistant', `Sorry, I encountered an error: ${escapeHtml(error.message)}`);
                } finally {
                    finished = true;
                    statusBarProgress.style.width = '100%';
                    setTimeout(() => {
                        statusBarProgress.style.transition = 'none';
                        statusBarProgress.style.width = '0%';
                        setTimeout(() => { statusBarProgress.style.transition = 'width 0.3s linear'; }, 50);
                        llmSendButton.disabled = false;
                        llmUserInput.disabled = false;
                        llmUserInput.focus();
                    }, 400);
                }
            }

            llmSendButton.addEventListener('click', sendLLMMessage);
            llmUserInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendLLMMessage();
                }
            });
        });
    </script>
</body>
</html>
